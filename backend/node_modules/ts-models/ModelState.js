"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var index_1 = require('ts-smart-logger/index');
var index_2 = require('ts-immutable-helper/index');
var AsyncState_1 = require('./AsyncState');
var Utils_1 = require('./Utils');
var ModelState = (function (_super) {
    __extends(ModelState, _super);
    function ModelState() {
        _super.apply(this, arguments);
        this.removed = false;
        this.pendingValues = {};
        this.values = {};
    }
    /**
     * @override
     */
    ModelState.prototype.setFieldValue = function (fieldName, fieldValue) {
        if (this.isRemovingInProgress()) {
            ModelState.logger.warn('[$ModelState][setFieldValue] The model does have a removable sync status');
            return this;
        }
        if (this.isRunning()) {
            if (Utils_1.Utils.isUndefined(fieldValue)) {
                delete this.pendingValues[fieldName];
                ModelState.logger.debug('[$ModelState][setFieldValue] The model pending state', this, 'is cleared when there is a server synchronization, field:', fieldName, ', value:', fieldValue);
            }
            else {
                this.pendingValues[fieldName] = fieldValue;
                ModelState.logger.debug('[$ModelState][setFieldValue] The model pending state', this, 'is updated when there is a server synchronization, field:', fieldName, ', value:', fieldValue);
            }
        }
        else {
            if (Utils_1.Utils.isUndefined(fieldValue)) {
                delete this.values[fieldName];
                ModelState.logger.debug('[$ModelState][setFieldValue] The model state', this, 'is cleared, field:', fieldName, ', value:', fieldValue);
            }
            else {
                this.values[fieldName] = fieldValue;
                ModelState.logger.debug('[$ModelState][setFieldValue] The model state', this, 'is updated, field:', fieldName, ', value:', fieldValue);
            }
        }
        return this;
    };
    /**
     * @override
     */
    ModelState.prototype.getFieldValue = function (fieldName) {
        var pendingValue = this.pendingValues[fieldName];
        if (Utils_1.Utils.isUndefined(pendingValue)) {
            return this.values[fieldName];
        }
        return pendingValue;
    };
    /**
     * @override
     */
    ModelState.prototype.isRemovingInProgress = function () {
        return this.removed && this.isRunning();
    };
    /**
     * The model has been removed on the server side if and only if the method return true and the model has no the running state
     *
     * @override
     */
    ModelState.prototype.isRemoved = function () {
        return this.removed && !this.isRunning();
    };
    /**
     * @override
     */
    ModelState.prototype.remove = function () {
        /**
         * Now we have the consistent state between the client and the server: the model not exists on the client,
         * but still exists on the server and process has started
         */
        this.start();
        this.removed = true;
    };
    /**
     * The consistent state has restored between the client and the server: the model still exists on the server and process has stopped
     *
     * @override
     */
    ModelState.prototype.restore = function () {
        this.removed = false;
        this.stop();
    };
    /**
     * @override
     */
    ModelState.prototype.commit = function () {
        var _this = this;
        if (!this.isRunning()) {
            ModelState.logger.warn('[$ModelState][commit] The model does not have a sync status. Open the transaction before using start method');
            return null;
        }
        var savedValues = index_2.ImmutableHelper.toImmutable(this.values);
        this.values = {};
        /**
         * Apply the pending values to the state
         */
        Object.keys(this.pendingValues).forEach(function (pendingValueName) {
            _this.values[pendingValueName] = _this.pendingValues[pendingValueName];
        });
        this.pendingValues = {};
        /**
         * Now we have the consistent state between the client and the server: the model does not have local changes and process has stopped
         */
        this.stop();
        return savedValues;
    };
    /**
     * @override
     */
    ModelState.prototype.rollback = function () {
        if (!this.isRunning()) {
            ModelState.logger.warn('[$ModelState][rollback] The model does not have a sync status. Open the transaction before using start method');
            return;
        }
        /**
         * Now we have the consistent state between the client and the server: the model does not have local changes and process has stopped
         */
        this.stop();
        this.values = {};
    };
    /**
     * @override
     */
    ModelState.prototype.getChanges = function () {
        return index_2.ImmutableHelper.toImmutable(this.values);
    };
    /**
     * @override
     */
    ModelState.prototype.hasChanges = function () {
        return Object.keys(this.values).length > 0;
    };
    ModelState.logger = index_1.LoggerFactory.makeLogger(ModelState);
    return ModelState;
}(AsyncState_1.AsyncState));
exports.ModelState = ModelState;
//# sourceMappingURL=ModelState.js.map