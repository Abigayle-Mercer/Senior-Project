import {
    ILogger,
    LoggerFactory
} from 'ts-smart-logger/index';

import {
    MetadataHelper,
    PropertyAnnotationFactory
} from 'ts-metadata-helper/index';

import {Utils} from './Utils';
import {IModel} from './IModel';

export class ViewSourceModelMetadata {
}
export const ViewSourceModel:Function = PropertyAnnotationFactory(ViewSourceModelMetadata);

class ViewSourceModelPropertyLookupService {

    private static logger:ILogger = LoggerFactory.makeLogger(ViewSourceModelPropertyLookupService);

    private annotatedProperty:string;

    constructor(private target:Object) {
    }

    lookup():string {
        if (Utils.isPresent(this.annotatedProperty)) {
            return this.annotatedProperty;
        }
        const annotatedProperties:Array<string> = Object.keys(MetadataHelper.findPropertyMetadata(this.target, ViewSourceModel));

        if (annotatedProperties.length === 0) {
            ViewSourceModelPropertyLookupService.logger.warn('[$ViewSourceModelPropertyLookupService] Source model is not found for the target', this.target,
                '. You forgot define @ViewSourceModel for source model property');
            return null;
        } else if (annotatedProperties.length > 1) {
            ViewSourceModelPropertyLookupService.logger.warn('[$ViewSourceModelPropertyLookupService] There is more than one source model');
        }
        return this.annotatedProperty = annotatedProperties[0];
    }
}

export interface IViewFieldMetadata {
    mapping:string;
}

export const ViewField:Function = function (metadata?:IViewFieldMetadata):Function {
    return (target:Object, propertyKey:string, descriptor:TypedPropertyDescriptor<any>) => {

        const lookupService = new ViewSourceModelPropertyLookupService(target);
        const toModel:Function = (view:Object, annotatedProperty:string):IModel => view[annotatedProperty] as IModel;

        const toViewPropertyKey:Function = (propertyKey:string):string => {
            return Utils.isBlank(metadata) || Utils.isBlank(metadata.mapping)
                ? propertyKey
                : metadata.mapping;
        };

        Reflect.defineProperty(target, propertyKey, {
            set: function (value) {
                const annotatedProperty:string = lookupService.lookup();
                if (Utils.isPresent(annotatedProperty)) {
                    toModel(this, annotatedProperty).setFieldValue(toViewPropertyKey(propertyKey), value);
                }
            },
            get: function () {
                const annotatedProperty:string = lookupService.lookup();
                return Utils.isBlank(annotatedProperty)
                    ? undefined
                    : toModel(this, annotatedProperty).getFieldValue(toViewPropertyKey(propertyKey));
            }
        });
        return descriptor;
    }
};
