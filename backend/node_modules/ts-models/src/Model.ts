import {ImmutableHelper} from 'ts-immutable-helper/index';

import {IModel} from './IModel';
import {IModelAttributes} from './IModelAttributes';
import {IModelState} from './IModelState';
import {ModelState} from './ModelState';
import {Utils} from './Utils';

export class Model<TAttributes> implements IModel, IModelAttributes<TAttributes> {
    
    private state:IModelState = new ModelState();
    protected attributes:TAttributes;

    constructor(attributes:TAttributes) {
        this.attributes = attributes || {} as TAttributes;
    }

    /**
     * @override
     */
    public setFieldValue(fieldName:string, fieldValue:any):IModel {
        if (this.attributes[fieldName] === fieldValue) {
            this.state.setFieldValue(fieldName, undefined);
        } else {
            this.state.setFieldValue(fieldName, fieldValue);
        }
        return this;
    }

    /**
     * @override
     */
    public getFieldValue(fieldName:string, defaultValue?:any):any {
        const stateValue:any = this.state.getFieldValue(fieldName);

        if (Utils.isUndefined(stateValue)) {
            const attributesValue:any = this.attributes[fieldName];
            if (Utils.isUndefined(attributesValue)) {
                const scopeValue:any = this[fieldName];
                if (Utils.isUndefined(scopeValue)) {
                    return defaultValue;
                }
                return scopeValue;
            } else {
                return attributesValue;
            }
        } else {
            return stateValue;
        }
    }

    /**
     * @override
     */
    public getChanges():TAttributes {
        return this.state.getChanges<TAttributes>();
    }

    /**
     * @override
     */
    public hasChanges():boolean {
        return this.state.hasChanges();
    }

    /**
     * @override
     */
    public isRemovingInProgress():boolean {
        return this.state.isRemovingInProgress();
    }

    /**
     * @override
     */
    public isRemoved():boolean {
        return this.state.isRemoved();
    }

    /**
     * @override
     */
    public isRunning():boolean {
        return this.state.isRunning();
    }

    /**
     * @override
     */
    public remove() {
        this.state.remove();
    }

    /**
     * @override
     */
    public restore() {
        this.state.restore();
    }

    /**
     * @override
     */
    public commit():TAttributes {
        const savedAttributes:TAttributes = this.state.commit<TAttributes>();

        if (Utils.isPresent(savedAttributes)) {
            /**
             * Apply saved values from state to the attributes of model.
             * The attributes - in fact, are a mirror of model state on the server
             */
            Object.assign(this.attributes, savedAttributes);            
        }
        return savedAttributes;
    }

    /**
     * @override
     */
    public rollback() {
        this.state.rollback();
    }

    /**
     * @override
     */
    public stop() {
        this.state.stop();
    }

    /**
     * @override
     */
    public start() {
        this.state.start();
    }

    /**
     * @override
     */
    public getId():any {
        return this.getFieldValue('id', null);
    }

    /**
     * @override
     */
    public toJSON():TAttributes {
        return ImmutableHelper.toImmutable<TAttributes>(this.attributes);
    }

    /**
     * @override
     */
    public toAttributes():TAttributes {
        const decoratedJSON:TAttributes = {} as TAttributes;

        Reflect.ownKeys(this.attributes).forEach((attributeName:string) => {
            Reflect.defineProperty(decoratedJSON, attributeName, {
                set: (value) => this.setFieldValue(attributeName, value),
                get: () => this.getFieldValue(attributeName)
            });
        });
        return decoratedJSON;
    }

    /**
     * @override
     */
    public toVirtualModel<TModel extends IModel>():TModel {
        return Reflect.construct(this.constructor, [this.attributes]);
    }
}
