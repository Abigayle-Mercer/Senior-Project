import {
    ILogger,
    LoggerFactory
} from 'ts-smart-logger/index';

import {ImmutableHelper} from 'ts-immutable-helper/index';

import {IModelState} from './IModelState';
import {AsyncState} from './AsyncState';
import {Utils} from './Utils';

export class ModelState<TAttributes extends {[index: string]: any;}> extends AsyncState implements IModelState {

    private static logger:ILogger = LoggerFactory.makeLogger(ModelState);

    private removed:boolean = false;

    private pendingValues:TAttributes = {} as TAttributes;
    private values:TAttributes = {} as TAttributes;

    /**
     * @override
     */
    public setFieldValue(fieldName:string, fieldValue:any):IModelState {
        if (this.isRemovingInProgress()) {
            ModelState.logger.warn('[$ModelState][setFieldValue] The model does have a removable sync status');
            return this;
        }

        if (this.isRunning()) {
            if (Utils.isUndefined(fieldValue)) {
                delete this.pendingValues[fieldName];

                ModelState.logger.debug('[$ModelState][setFieldValue] The model pending state', this, 'is cleared when there is a server synchronization, field:', fieldName, ', value:', fieldValue);
            } else {
                this.pendingValues[fieldName] = fieldValue;

                ModelState.logger.debug('[$ModelState][setFieldValue] The model pending state', this, 'is updated when there is a server synchronization, field:', fieldName, ', value:', fieldValue);
            }
        } else {
            if (Utils.isUndefined(fieldValue)) {
                delete this.values[fieldName];

                ModelState.logger.debug('[$ModelState][setFieldValue] The model state', this, 'is cleared, field:', fieldName, ', value:', fieldValue);
            } else {
                this.values[fieldName] = fieldValue;

                ModelState.logger.debug('[$ModelState][setFieldValue] The model state', this, 'is updated, field:', fieldName, ', value:', fieldValue);
            }
        }
        return this;
    }

    /**
     * @override
     */
    public getFieldValue(fieldName:string):any {
        const pendingValue:any = this.pendingValues[fieldName];
        if (Utils.isUndefined(pendingValue)) {
            return this.values[fieldName];
        }
        return pendingValue;
    }

    /**
     * @override
     */
    public isRemovingInProgress():boolean {
        return this.removed && this.isRunning();
    }

    /**
     * The model has been removed on the server side if and only if the method return true and the model has no the running state
     *
     * @override
     */
    public isRemoved():boolean {
        return this.removed && !this.isRunning();
    }

    /**
     * @override
     */
    public remove() {
        /**
         * Now we have the consistent state between the client and the server: the model not exists on the client,
         * but still exists on the server and process has started
         */
        this.start();
        this.removed = true;
    }

    /**
     * The consistent state has restored between the client and the server: the model still exists on the server and process has stopped
     *
     * @override
     */
    public restore() {
        this.removed = false;
        this.stop();
    }

    /**
     * @override
     */
    public commit():TAttributes {
        if (!this.isRunning()) {
            ModelState.logger.warn('[$ModelState][commit] The model does not have a sync status. Open the transaction before using start method');
            return null;
        }

        const savedValues:TAttributes = ImmutableHelper.toImmutable<TAttributes>(this.values);

        this.values = {} as TAttributes;

        /**
         * Apply the pending values to the state
         */
        Object.keys(this.pendingValues).forEach((pendingValueName:string) => {
            this.values[pendingValueName] = this.pendingValues[pendingValueName];
        });
        this.pendingValues = {} as TAttributes;

        /**
         * Now we have the consistent state between the client and the server: the model does not have local changes and process has stopped
         */
        this.stop();

        return savedValues;
    }

    /**
     * @override
     */
    public rollback() {
        if (!this.isRunning()) {
            ModelState.logger.warn('[$ModelState][rollback] The model does not have a sync status. Open the transaction before using start method');
            return;
        }

        /**
         * Now we have the consistent state between the client and the server: the model does not have local changes and process has stopped
         */
        this.stop();

        this.values = {} as TAttributes;
    }

    /**
     * @override
     */
    public getChanges():TAttributes {
        return ImmutableHelper.toImmutable<TAttributes>(this.values);
    }

    /**
     * @override
     */
    public hasChanges():boolean {
        return Object.keys(this.values).length > 0;
    }
}
