import {Model} from './Model';

import {
    ViewSourceModel,
    ViewField
} from './decorators';

interface IViewModel {
    name:string;
}

interface IProduct {
    id:number;
    name:string;
    description:string;
    exists:boolean;
}

class Product extends Model<IProduct> {

    constructor(protected attributes:IProduct) {
        super(attributes);
    }
}

describe('Model', ()=> {
    describe('Checking the Model functionality', ()=> {

        it('Commit method should work correctly', ()=> {
            const product:Product = new Product({
                id: 100,
                name: 'Name1',
                description: 'Description1',
                exists: true
            });

            const mutableAttributes:IProduct = product.toAttributes();
            mutableAttributes.description = 'Changed description1';
            mutableAttributes.exists = false;
            expect(Object.keys(product.getChanges())).toEqual(['description', 'exists']);

            product.start();
            product.commit();
            expect(Object.keys(product.getChanges())).toEqual([]);
            expect(product.toJSON().description).toEqual('Changed description1');

            const virtualProduct1:Product = product.toVirtualModel<Product>();
            const virtualProduct2:Product = product.toVirtualModel<Product>();

            const mutableVirtualAttributes1:IProduct = virtualProduct1.toAttributes();
            const mutableVirtualAttributes2:IProduct = virtualProduct2.toAttributes();

            mutableVirtualAttributes1.description = 'Changed description2';
            mutableVirtualAttributes2.description = 'Changed description3';

            expect(virtualProduct1.getChanges().description).toEqual('Changed description2');
            expect(virtualProduct2.getChanges().description).toEqual('Changed description3');
            expect(product.toJSON().description).toEqual('Changed description1');
        });

        it('Rollback method should work correctly', ()=> {
            const product:Product = new Product({
                id: 100,
                name: 'Name1',
                description: 'Description1',
                exists: true
            });

            expect(Object.keys(product.getChanges())).toEqual([]);

            product.setFieldValue('name', 'Name2');
            expect(Object.keys(product.getChanges())).toEqual(['name']);
            product.start();
            product.rollback();

            expect(Object.keys(product.getChanges())).toEqual([]);
        });

        it('Decorators should work correctly', ()=> {

            class ViewModel implements IViewModel {

                @ViewField()
                name:string;

                @ViewSourceModel()
                get sourceModel():Product {
                    return this._model;
                }

                constructor(private _model:Product) {
                }
            }

            const product:Product = new Product({
                id: 100,
                name: 'Name1',
                description: 'Description1',
                exists: true
            });

            const viewModel:IViewModel = new ViewModel(product);

            // Binding via UI-framework
            viewModel.name = 'Name2';

            expect(product.getFieldValue('name')).toEqual('Name2');
            expect(product.toAttributes().name).toEqual('Name2');
            expect(Object.keys(product.getChanges())).toEqual(['name']);
        });
    });
});
